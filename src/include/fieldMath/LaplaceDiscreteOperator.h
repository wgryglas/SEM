
#ifndef LAPLACEDISCRETEOPERATOR_H
#define LAPLACEDISCRETEOPERATOR_H

#include "utilities/Reference.h"
#include "iomanagment/InfoStream.h"
#include "fields/GeometricField.h"
#include "mesh/Mesh.h"
#include "elements/RealElement.h"
#include "solver/DiscretOperator.h"
#include "solver/EquationPart.h"
#include "solver/EquationMatrix.h"
#include "utilities/Reference.h"
#include "components/CmpTraits.h"
#include "utilities/ArrayFunctions.h"


namespace SEM {

template<typename T, typename Coeff>
class LaplaceDiscreteOperator : public las::DiscretOperator<T,LaplaceDiscreteOperator<T,Coeff> >
{
    field::GeometricField<T> &m_field;
public:
    
    LaplaceDiscreteOperator(field::GeometricField<T> &field, const Coeff &coefficient)
    : m_coeff(coefficient), m_field(field)
    {
    }
    
    SEM::field::GeometricField<T> *field() { return &m_field;}
    
    DECLARE_AND_BLOCK_DIAGONAL_TYPE(LaplaceDiscreteOperator)
    
    template<typename Assigner>
    void buildImplicit(const mesh::Mesh &mesh, las::SEMMatrix &matrix, las::SEMVector &rhsVector, const las::AssigmentBase<Assigner> & assigner) const;
    
    template<typename Assugner>
    void buildExplicit(const mesh::Mesh &mesh, las::SEMVector &rhsVector, const las::AssigmentBase<Assugner> & assign) const;
    
private:
    const Coeff m_coeff;
};

template<typename T,typename Coeff>
template<typename Assigner>
void LaplaceDiscreteOperator<T,Coeff>::buildImplicit(const mesh::Mesh &elements, las::SEMMatrix &matrix, las::SEMVector &rhsVector, const las::AssigmentBase<Assigner> & assign) const
{
    using namespace iomanagment;
    using namespace las;
    using namespace field;
    
    InfoArrow<<"building stiffnes matrix ...."<<std::endl;
    
    size_t dimSize = CmpTraits<T>::dim();
    
    //assigne element matrix generated by element to collecion of local matrices
    for( size_t e=0; e < elements.size(); ++e )
    {
        numArray2D<Scalar> eStiff=elements[e].stiffMatrix(m_coeff);
        
        //iterate over filed dimensions 
        for(size_t dim=0; dim<dimSize; ++dim)
        {
            assign(eStiff,matrix[dim][e]);
        }
    }
}

template<typename T,typename Coeff>
template<typename Assigner>
void LaplaceDiscreteOperator<T,Coeff>::buildExplicit(const mesh::Mesh &elements, las::SEMVector &rhsVector, const las::AssigmentBase<Assigner> & assign) const
{
//     using namespace iomanagment;
//     using namespace las;
//     using namespace field;
//     
//     InfoArrow<<"evaluating laplace operator ...."<<std::endl;
//     
//     //temp element matrix
//     numArray2D<Scalar> eStiff;
//     
//     
//     size_t dimSize = CmpTraits<T>::dim();
//     
//     //assigne element matrix generated by element to collecion of local matrices
//     size_t nelements = elements.size();
//     
//     std::cout<<"number of elements "<<nelements<<std::endl;
//     
//     for( size_t e=0; e < nelements; ++e )
//     {
//         std::cout<<"element "<<e<<"\t";
//         
//         numArray2D<Scalar> eStiff=elements[e].stiffMatrix(m_coeff);
//         
//         //iterate over filed dimensions 
//         for(size_t dim=0; dim<dimSize; ++dim)
//         {
//             auto localRhs = rhsVector[dim].slice(elements[e].indexVectorMask());
//             auto cmpField = CmpTraits<T>::cmpArray(m_field,dim);
//             auto localCmpField = cmpField.slice(elements[e].indexVectorMask());
//             assign( array::matrixMul(eStiff,localCmpField), localRhs );
//         }
//     }
}


}//SEM

#endif // LAPLACEDISCRETEOPERATOR_H

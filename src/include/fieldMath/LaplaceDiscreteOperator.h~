
#ifndef LAPLACEDISCRETEOPERATOR_H
#define LAPLACEDISCRETEOPERATOR_H

#include "utilities/Reference.h"
#include "iomanagment/InfoStream.h"
#include "fields/GeometricField.h"
#include "mesh/Mesh.h"
#include "elements/RealElement.h"
#include "solver/DiscretOperator.h"
#include "solver/EquationPart.h"
#include "solver/EquationMatrix.h"
#include "utilities/Reference.h"
#include "components/CmpTraits.h"
#include "utilities/ArrayFunctions.h"


namespace SEM {

template<typename T, typename Coeff>
class LaplaceDiscreteOperator : public las::DiscretOperator<T,LaplaceDiscreteOperator<T,Coeff> >
{
    field::GeometricField<T> &m_field;
public:
    
    LaplaceDiscreteOperator(field::GeometricField<T> &field, const Coeff &coefficient)
    : m_coeff(coefficient), m_field(field)
    {
    }
    
    SEM::field::GeometricField<T> *field() { return &m_field;}
    
    template<typename Assigner>
    void buildImplicit(const mesh::Mesh &mesh, las::SEMMatrix &matrix, las::SEMVector &rhsVector, const las::AssigmentBase<Assigner> & assigner) const;
    
    template<typename Assugner>
    void buildExplicit(const mesh::Mesh &mesh, las::SEMVector &rhsVector, const las::AssigmentBase<Assugner> & assign) const;
    
private:
    const Coeff m_coeff;
};

template<typename T,typename Coeff>
template<typename Assigner>
void LaplaceDiscreteOperator<T,Coeff>::buildImplicit(const mesh::Mesh &elements, las::SEMMatrix &matrix, las::SEMVector &rhsVector, const las::AssigmentBase<Assigner> & assign) const
{
    using namespace iomanagment;
    using namespace las;
    using namespace field;
    
    InfoArrow<<"building stiffnes matrix ...."<<std::endl;
    
    size_t dimSize = CmpTraits<T>::dim();
    
    //assigne element matrix generated by element to collecion of local matrices
    for( size_t e=0; e < elements.size(); ++e )
    {
        numArray2D<Scalar> eStiff=elements[e].stiffMatrix(m_coeff);
        
        //iterate over filed dimensions 
        for(size_t dim=0; dim<dimSize; ++dim)
        {
            assign(eStiff,matrix[dim][e]);
        }
    }
}

template<typename T,typename Coeff>
template<typename Assigner>
void LaplaceDiscreteOperator<T,Coeff>::buildExplicit(const mesh::Mesh &elements, las::SEMVector &rhsVector, const las::AssigmentBase<Assigner> & assign) const
{
    using namespace iomanagment;
    using namespace las;
    using namespace field;
    
    InfoArrow<<"evaluating laplace operator ...."<<std::endl;
    
    //temp element matrix
    numArray2D<Scalar> eStiff;
    
    size_t dimSize = CmpTraits<T>::dim();
    
    //assigne element matrix generated by element to collecion of local matrices
    for( size_t e=0; e < elements.size(); ++e )
    {
        numArray2D<Scalar> eStiff=elements[e].stiffMatrix(m_coeff);
        
        //iterate over filed dimensions 
        for(size_t dim=0; dim<dimSize; ++dim)
        {
            auto localRhs = rhsVector[dim].slice(elements[e].indexVectorMask());
            auto cmpField = CmpTraits<T>::cmpArray(m_field,dim);
            auto localCmpField = cmpField.slice(elements[e].indexVectorMask());
            assign( array::matrixMul(eStiff,localCmpField), localRhs );
        }
    }

// It's moved to diffrent operator    
//     //Apply integrals from Neumann BC
//     //iterate over patches
//     for(const typename GeometricField<T>::Patch* patch : m_field.boundaryFields())
//     {
//         if(patch->neumanCoeff()==0)
//             continue;
//         
//         const mesh::Boundary & edges = patch->boundaryEdges();
//         //iterate over edges in boundary
//         for(int e=0; e<edges.size(); ++e)
//         {
//             //iterate over filed dimensions
//             for(size_t dim=0; dim < dimSize; ++dim)
//             {
//                 numArray<Scalar>::indexMapped rhsSlice(rhsVector[dim],edges[e].gNodesIds());
//                 
//                 Scalar patchValue = CmpTraits<T>::component( (*patch)[e], dim);
//                 
//                 assign( edges[e].neumanBCPreValue()*patchValue*patch->neumanCoeff(), rhsSlice);
//             }
//         }
//     }    
    
}


}//SEM

#endif // LAPLACEDISCRETEOPERATOR_H
